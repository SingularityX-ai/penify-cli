import json
import random
import sys
import os
import argparse
from pathlib import Path
import webbrowser
import http.server
import socketserver
import urllib.parse
from threading import Thread

from .commit_analyzer import CommitDocGenHook
from .folder_analyzer import FolderAnalyzerGenHook
from .file_analyzer import FileAnalyzerGenHook
from .api_client import APIClient
from .git_analyzer import GitDocGenHook

HOOK_FILENAME = "post-commit"
HOOK_TEMPLATE = """#!/bin/sh
# This is a post-commit hook generated by penify-cli.

penify-cli -t {token} -gf {git_folder_path}
"""
api_url = 'https://production-gateway.snorkell.ai/api'
dashboard_url = "https://dashboard.penify.dev/auth/localhost/login"
# api_url = 'http://localhost:8000/api'

def install_git_hook(location, token):
    """
    Install a post-commit hook in the specified location.
    Args:
        location (str): The path to the Git repository.
        token (str): The token to be used in the hook.
    Raises:
        SystemExit: If the hooks directory does not exist.
    Returns:
        None
    """
    hooks_dir = Path(location) / ".git/hooks"
    hook_path = hooks_dir / HOOK_FILENAME
    
    if not hooks_dir.exists():
        print(f"Error: The hooks directory {hooks_dir} does not exist.")
        sys.exit(1)
    
    hook_content = HOOK_TEMPLATE.format(token=token, git_folder_path=location)
    hook_path.write_text(hook_content)
    hook_path.chmod(0o755)  # Make the hook script executable

    print(f"Post-commit hook installed in {hook_path}")

def uninstall_git_hook(location):
    """
    Uninstalls the post-commit hook from the specified location.
    Parameters:
    - location (str): The path to the directory containing the Git repository.
    Returns:
    None
    """
    hook_path = Path(location) / ".git/hooks" / HOOK_FILENAME
    
    if hook_path.exists():
        hook_path.unlink()
        print(f"Post-commit hook uninstalled from {hook_path}")
    else:
        print(f"No post-commit hook found in {hook_path}")

def generate_doc(token, file_path=None, complete_folder_path=None, git_folder_path=None):
    """
    Generates documentation based on the given parameters.
    Parameters:
    - token (str): The API token for authentication.
    - file_path (str, optional): The path to a specific file to generate documentation for.
    - complete_folder_path (str, optional): The path to a complete folder to generate documentation for.
    - git_folder_path (str, optional): The path to a Git repository folder to generate documentation for.
    """
    
    api_client = APIClient(api_url, token)

    if file_path:
        try:
            analyzer = FileAnalyzerGenHook(file_path, api_client)
            analyzer.run()
        except Exception as e:
            print(f"Error: {e}")
            sys.exit(1)
    elif complete_folder_path:
        try:
            analyzer = FolderAnalyzerGenHook(complete_folder_path, api_client)
            analyzer.run()
        except Exception as e:
            print(f"Error: {e}")
            sys.exit(1)
    else:
        try:
            analyzer = GitDocGenHook(git_folder_path, api_client)
            analyzer.run()
        except Exception as e:
            print(f"Error: {e}")
            sys.exit(1)
    
def commit_code(gf_path: str, token: str, message: str, open_terminal: bool):
    # Implement the logic to perform a commit with a message
    api_client = APIClient(api_url, token)
    try:
        analyzer = CommitDocGenHook(gf_path, api_client)
        analyzer.run(message, open_terminal)
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)
    # You can add actual Git commit logic here using subprocess or GitPython, etc.

def save_credentials(api_key):
    """
    Save the token and API keys in the .penify file in the user's home directory.
    """
    home_dir = Path.home()
    penify_file = home_dir / '.penify'

    credentials = {
        'api_keys': api_key
    }

    try:
        with open(penify_file, 'w') as f:
            json.dump(credentials, f)
    except Exception as e:
        print(f"Error saving credentials: {str(e)}")

def login():
    """
    Open the login page in a web browser and listen for the redirect URL to capture the token.
    """
    
    # dashboard_url = "http://localhost:8000/auth/localhost/login"
    redirect_port = random.randint(30000, 50000)
    redirect_url = f"http://localhost:{redirect_port}/callback"
    
    full_login_url = f"{dashboard_url}?redirectUri={urllib.parse.quote(redirect_url)}"
    
    print(f"Opening login page in your default web browser: {full_login_url}")
    webbrowser.open(full_login_url)
    
    class TokenHandler(http.server.SimpleHTTPRequestHandler):
        def do_GET(self):
            query = urllib.parse.urlparse(self.path).query
            query_components = urllib.parse.parse_qs(query)
            token = query_components.get("token", [None])[0]
            
            if token:
                self.send_response(200)
                self.send_header("Content-type", "text/html")
                self.end_headers()
                response = """
                <html>
                <head>
                    <script>
                        setTimeout(function() {
                            window.location.href = 'https://dashboard.penify.dev';
                        }, 5000);
                    </script>
                </head>
                <body>
                    <h1>Login Successful!</h1>
                    <p>You will be redirected to the Penify dashboard in 5 seconds. You can also close this window and return to the CLI.</p>
                </body>
                </html>
                """
                self.wfile.write(response.encode())
                
                print(f"\nLogin successful! Fetching API keys...")
                api_key = APIClient(api_url, None, token).get_api_key()
                if api_key:
                    save_credentials(api_key)
                    print("API keys fetched and saved successfully.")
                    print("You'll be redirected to the Penify dashboard. You can continue using the CLI.")
                else:
                    print("Failed to fetch API keys.")
            else:
                self.send_response(400)
                self.send_header("Content-type", "text/html")
                self.end_headers()
                response = """
                <html>
                <body>
                <h1>Login Failed</h1>
                <p>Please try again.</p>
                </body>
                </html>
                """
                self.wfile.write(response.encode())
                print("\nLogin failed. Please try again.")
            
            # Schedule the server shutdown
            thread = Thread(target=self.server.shutdown)
            thread.daemon = True
            thread.start()

        def log_message(self, format, *args):
            # Suppress log messages
            return
    
    with socketserver.TCPServer(("", redirect_port), TokenHandler) as httpd:
        print(f"Listening on port {redirect_port} for the redirect...")
        httpd.serve_forever()
    
    print("Login process completed. You can now use other commands with your API token.")


def get_token(passed_token):
    """
    Get the token based on priority:
    1. Passed parameter
    2. Environment variable
    3. Config file
    """
    if passed_token:
        return passed_token
    
    env_token = os.getenv('PENIFY_API_TOKEN')
    if env_token:
        return env_token
    
    config_file = Path.home() / '.penify'
    if config_file.exists():
        try:
            with open(config_file, 'r') as f:
                config = json.load(f)
                return config.get('api_keys')
        except json.JSONDecodeError:
            print("Error reading .penify config file. File may be corrupted.")
        except Exception as e:
            print(f"Error reading .penify config file: {str(e)}")
    
    return None

def main():
    parser = argparse.ArgumentParser(description="Penify CLI tool for managing Git hooks and generating documentation.")
    
    parser.add_argument("-t", "--token", help="API token for authentication. If not provided, will check PENIFY_API_TOKEN environment variable, then .penify config file.")

    subparsers = parser.add_subparsers(title="subcommands", dest="subcommand")

    # Subcommand: install-hook
    install_parser = subparsers.add_parser("install-hook", help="Install the Git post-commit hook.")
    install_parser.add_argument("-l", "--location", required=True, help="Location in which to install the Git hook.")

    # Subcommand: uninstall-hook
    uninstall_parser = subparsers.add_parser("uninstall-hook", help="Uninstall the Git post-commit hook.")
    uninstall_parser.add_argument("-l", "--location", required=True, help="Location from which to uninstall the Git hook.")

    # Subcommand: doc-gen
    doc_gen_parser = subparsers.add_parser("doc-gen", help="Generate documentation for specified files or folders.")
    doc_gen_parser.add_argument("-fl", "--file_path", help="Path of the file to generate documentation.")
    doc_gen_parser.add_argument("-cf", "--complete_folder_path", help="Generate documentation for the entire folder.")
    doc_gen_parser.add_argument("-gf", "--git_folder_path", help="Path to the folder, with git, to scan for modified files. Defaults to the current folder.", default=os.getcwd())

    # Subcommand: commit
    commit_parser = subparsers.add_parser("commit", help="Commit with a message.")
    commit_parser.add_argument("-gf", "--git_folder_path", help="Path to the folder, with git, to scan for modified files. Defaults to the current folder.", default=os.getcwd())
    commit_parser.add_argument("-m", "--message", required=False, help="Commit message.", default="N/A")
    commit_parser.add_argument("-e", "--terminal", required=False, help="Open edit terminal", default="False")

    # Subcommand: login
    login_parser = subparsers.add_parser("login", help="Log in to Penify and obtain an API token.")

    args = parser.parse_args()

    # Get the token based on priority
    token = get_token(args.token)

    if args.subcommand == "install-hook":
        if not token:
            print("Error: API token is required. Please provide it using -t option, PENIFY_API_TOKEN environment variable, or log in first.")
            sys.exit(1)
        install_git_hook(args.location, token)
    elif args.subcommand == "uninstall-hook":
        uninstall_git_hook(args.location)
    elif args.subcommand == "doc-gen":
        if not token:
            print("Error: API token is required. Please provide it using -t option, PENIFY_API_TOKEN environment variable, or log in first.")
            sys.exit(1)
        generate_doc(token, args.file_path, args.complete_folder_path, args.git_folder_path)
    elif args.subcommand == "commit":
        if not token:
            print("Error: API token is required. Please provide it using -t option, PENIFY_API_TOKEN environment variable, or log in first.")
            sys.exit(1)
        open_terminal = args.terminal.lower() == "true"
        commit_code(args.git_folder_path, token, args.message, open_terminal)
    elif args.subcommand == "login":
        login()
    else:
        parser.print_help()
        sys.exit(1)

if __name__ == "__main__":
    main()
